import { openai } from '@ai-sdk/openai'
import { streamText, generateText, tool, embed, convertToModelMessages } from 'ai'
import { z } from 'zod'
import { supabase } from '@/lib/supabase'

// Sistema de mensagens para a Vision Marine AI
const VISION_MARINE_SYSTEM_PROMPT = `
Voc√™ √© a assistente virtual oficial da Vision Marine, a principal plataforma de educa√ß√£o mar√≠tima e naval do Brasil.

IDENTIDADE:
- Nome: Assistente Vision Marine
- Especialidade: Treinamentos mar√≠timos, certifica√ß√µes navais, cursos especializados
- Tom: Profissional, prestativo, conhecedor do setor mar√≠timo
- Idioma: Portugu√™s brasileiro

CONHECIMENTO BASE:
A Vision Marine oferece:
- Treinamentos especializados em Dynamic Positioning (DP)
- Certifica√ß√µes internacionais
- Cursos online e presenciais
- Forma√ß√£o para profissionais mar√≠timos
- Simuladores profissionais
- Aulas 100% online com suporte 24/7

DIRETRIZES:
1. Sempre seja prestativo e profissional
2. Forne√ßa informa√ß√µes precisas sobre nossos treinamentos
3. Se n√£o souber algo espec√≠fico, sugira contato direto
4. Incentive a certifica√ß√£o e desenvolvimento profissional
5. Use linguagem t√©cnica adequada para o setor mar√≠timo
6. Seja emp√°tico com as necessidades de carreira dos usu√°rios

LIMITA√á√ïES:
- N√£o invente pre√ßos ou datas espec√≠ficas sem confirma√ß√£o
- Para informa√ß√µes muito espec√≠ficas, direcione para contato direto
- Sempre mantenha foco em educa√ß√£o mar√≠tima
`

// Tool para buscar cursos dispon√≠veis
const getCourseInformation = tool({
  description: 'Busca informa√ß√µes sobre cursos e treinamentos dispon√≠veis na Vision Marine',
  inputSchema: z.object({
    query: z.string(),
    categoria: z.string().nullable()
  }),
  execute: async ({ query, categoria }) => {
    try {
      let supabaseQuery = supabase
        .from('vw_proximos_cursos')
        .select('*')
        .order('data_inicio', { ascending: true })
        .limit(5)

      // Aplicar filtros baseados na query
      if (categoria) {
        supabaseQuery = supabaseQuery.ilike('categoria', `%${categoria}%`)
      }

      if (query) {
        supabaseQuery = supabaseQuery.or(
          `curso_nome.ilike.%${query}%,descricao.ilike.%${query}%,instrutor.ilike.%${query}%`
        )
      }

      const { data: courses, error } = await supabaseQuery

      if (error) {
        console.error('Erro ao buscar cursos:', error)
        return {
          success: false,
          message: 'Erro ao buscar informa√ß√µes dos cursos. Tente novamente ou entre em contato conosco.'
        }
      }

      if (!courses || courses.length === 0) {
        return {
          success: true,
          message: 'N√£o encontrei cursos espec√≠ficos para sua busca. Temos diversos treinamentos especializados em Dynamic Positioning, Navega√ß√£o e Seguran√ßa Mar√≠tima. Entre em contato para mais informa√ß√µes.',
          courses: []
        }
      }

      return {
        success: true,
        courses: courses.map(course => ({
          nome: course.curso_nome,
          descricao: course.descricao,
          nivel: course.nivel,
          carga_horaria: course.carga_horaria,
          preco: course.preco,
          categoria: course.categoria,
          instrutor: course.instrutor,
          data_inicio: course.data_formatada,
          vagas_disponiveis: course.vagas_disponiveis,
          modalidade: course.modalidade,
          local: course.local
        })),
        message: `Encontrei ${courses.length} curso(s) relacionado(s) √† sua busca.`
      }
    } catch (error) {
      console.error('Erro inesperado ao buscar cursos:', error)
      return {
        success: false,
        message: 'Erro interno. Entre em contato conosco para mais informa√ß√µes.'
      }
    }
  }
})

// Tool para informa√ß√µes de contato
const getContactInformation = tool({
  description: 'Fornece informa√ß√µes de contato da Vision Marine',
  inputSchema: z.object({
    tipo: z.enum(['geral', 'comercial', 'suporte', 'certificacao'])
  }),
  execute: async ({ tipo }) => {
    const contactInfo = {
      geral: {
        email: 'contato@visionmarine.com.br',
        telefone: '(11) 99999-9999',
        endereco: 'Av. Atl√¢ntica, 1000 - Santos, SP - Brasil',
        horario: 'Segunda a Sexta: 8h √†s 18h'
      },
      comercial: {
        email: 'vendas@visionmarine.com.br',
        telefone: '(11) 99999-9999',
        whatsapp: '(11) 99999-9999',
        message: 'Nossa equipe comercial est√° pronta para ajudar com or√ßamentos e informa√ß√µes sobre nossos treinamentos.'
      },
      suporte: {
        email: 'suporte@visionmarine.com.br',
        telefone: '(11) 99999-9999',
        disponibilidade: '24/7',
        message: 'Suporte t√©cnico dispon√≠vel 24 horas por dia, 7 dias por semana.'
      },
      certificacao: {
        email: 'certificacao@visionmarine.com.br',
        telefone: '(11) 99999-9999',
        message: 'Equipe especializada em certifica√ß√µes internacionais e valida√ß√£o de cursos.'
      }
    }

    return {
      success: true,
      contato: contactInfo[tipo],
      message: `Aqui est√£o as informa√ß√µes de contato para ${tipo}.`
    }
  }
})

// Tool para estat√≠sticas da Vision Marine
const getCompanyStats = tool({
  description: 'Fornece estat√≠sticas e n√∫meros da Vision Marine',
  inputSchema: z.object({
    tipo: z.enum(['geral', 'cursos', 'alunos', 'certificacoes'])
  }),
  execute: async ({ tipo }) => {
    const stats = {
      geral: {
        alunos_formados: '2.500+',
        treinamentos_disponiveis: '50+',
        taxa_aprovacao: '98%',
        anos_experiencia: '15+',
        message: 'A Vision Marine √© l√≠der em educa√ß√£o mar√≠tima no Brasil.'
      },
      cursos: {
        total_cursos: '50+',
        modalidades: ['Online', 'Presencial', 'H√≠brido'],
        categorias: ['Dynamic Positioning', 'Navega√ß√£o', 'Seguran√ßa', 'Simula√ß√£o'],
        message: 'Oferecemos ampla variedade de treinamentos especializados.'
      },
      alunos: {
        alunos_ativos: '500+',
        alunos_formados: '2.500+',
        paises_atendidos: '5+',
        message: 'Nossa comunidade de profissionais mar√≠timos cresce continuamente.'
      },
      certificacoes: {
        certificacoes_emitidas: '2.500+',
        taxa_aprovacao: '98%',
        validade_internacional: true,
        message: 'Nossas certifica√ß√µes s√£o reconhecidas internacionalmente.'
      }
    }

    return {
      success: true,
      dados: stats[tipo],
      message: stats[tipo].message
    }
  }
})

// Interface para resultados RAG
interface RAGResult {
  title: string;
  content_chunk: string;
  type: string;
  category: string;
  similarity: number;
  metadata: Record<string, unknown>;
}

// Tool para busca sem√¢ntica RAG
const searchKnowledgeBase = tool({
  description: 'Busca informa√ß√µes relevantes na base de conhecimento usando similaridade sem√¢ntica',
  inputSchema: z.object({
    query: z.string(),
    threshold: z.number().nullable(),
    limit: z.number().nullable()
  }),
  execute: async ({ query, threshold, limit }) => {
    const finalThreshold = threshold || 0.7
    const finalLimit = limit || 5
    try {
      // Gerar embedding da query do usu√°rio
      const { embedding } = await embed({
        model: openai.embedding('text-embedding-3-small'),
        value: query
      })

      // Buscar conte√∫do similar no banco
      const { data, error } = await supabase.rpc('match_vision_marine_content', {
        query_embedding: embedding,
        match_threshold: finalThreshold,
        match_count: finalLimit
      })

      if (error) {
        console.error('Erro na busca RAG:', error)
        return {
          success: false,
          message: 'Erro ao buscar informa√ß√µes na base de conhecimento.',
          results: []
        }
      }

      if (!data || data.length === 0) {
        return {
          success: true,
          message: 'N√£o encontrei informa√ß√µes espec√≠ficas sobre sua consulta na nossa base de conhecimento.',
          results: []
        }
      }

      return {
        success: true,
        message: `Encontrei ${data.length} informa√ß√£o(√µes) relevante(s) sobre sua consulta.`,
        results: data.map((item: RAGResult) => ({
          title: item.title,
          content: item.content_chunk,
          type: item.type,
          category: item.category,
          similarity: Math.round(item.similarity * 100),
          metadata: item.metadata
        }))
      }
    } catch (error) {
      console.error('Erro inesperado na busca RAG:', error)
      return {
        success: false,
        message: 'Erro interno na busca por informa√ß√µes.',
        results: []
      }
    }
  }
})

export async function POST(req: Request) {
  try {
    const body = await req.json()
    const { messages } = body

    console.log('üì• Body recebido:', JSON.stringify(body, null, 2))
    console.log('üì• Mensagens extra√≠das:', JSON.stringify(messages, null, 2))

    // Validar se messages existe e √© um array
    if (!messages || !Array.isArray(messages)) {
      console.error('‚ùå Messages inv√°lido:', messages)
      return new Response(
        JSON.stringify({
          error: 'Formato de mensagens inv√°lido. Esperado um array de mensagens.'
        }),
        {
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      )
    }

    // Validar se h√° pelo menos uma mensagem
    if (messages.length === 0) {
      console.error('‚ùå Array de messages vazio')
      return new Response(
        JSON.stringify({
          error: 'Nenhuma mensagem foi enviada.'
        }),
        {
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      )
    }

    console.log('‚úÖ Messages v√°lido, convertendo formato...')

    // Converter mensagens do formato v4 (content) para v5 (parts)
    const convertedMessages = messages.map(message => {
      // Se j√° estiver no formato v5 (com parts), manter
      if (message.parts) {
        return message
      }

      // Se estiver no formato v4 (com content), converter para v5
      if (message.content) {
        return {
          ...message,
          parts: [
            {
              type: 'text',
              text: message.content
            }
          ]
        }
      }

      // Se n√£o tiver nem content nem parts, erro
      throw new Error(`Mensagem inv√°lida: ${JSON.stringify(message)}`)
    })

    console.log('‚úÖ Messages convertidas para v5:', JSON.stringify(convertedMessages, null, 2))

    // Verificar se convertedMessages est√° v√°lido antes de converter
    if (!convertedMessages || !Array.isArray(convertedMessages)) {
      throw new Error('Converted messages is not a valid array')
    }

    const modelMessages = convertToModelMessages(convertedMessages)
    console.log('‚úÖ Model messages:', JSON.stringify(modelMessages, null, 2))

    console.log('ü§ñ Iniciando streamText com gpt-4o...')
    const result = await streamText({
      // Modelo atual: gpt-4o (funciona com streaming)
      model: openai('gpt-4o'),
      // Para usar gpt-5-mini no futuro quando streaming for liberado:
      // model: openai('gpt-5-mini'),
      system: VISION_MARINE_SYSTEM_PROMPT,
      messages: modelMessages,
      tools: {
        getCourseInformation,
        getContactInformation,
        getCompanyStats,
        searchKnowledgeBase
      },
      maxToolRoundtrips: 3,
      temperature: 0.7,
    })

    console.log('‚úÖ StreamText criado, convertendo para UIMessageStreamResponse...')
    return result.toUIMessageStreamResponse()
  } catch (error) {
    console.error('üí• Erro na API do chat:', error)
    return new Response(
      JSON.stringify({
        error: 'Erro interno do servidor. Tente novamente em alguns instantes.'
      }),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    )
  }
}